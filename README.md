# Steam Analytics

### Архитектура вкратце
Приложение разбито на фреймворки нескольких уровней. `Core` содержит базовые структуры данных приложения (`User`, `Game` etc). `Storages` персистит данные в `CoreData` посредством `CoreStore`. `APIClient` раширяет структуры из `Core` до `Codable`, обеспечивает загрузку данных из сети. `Services` содержит сервисы для работы с данными, получает данные из сети с помощью `APIClient` и кладет их в `Storages`. Фреймворк `UICommon` содержит ui-элементы и их модели, абстракции координаторов, а так же тестовое приложение для UI-элементов. Выше идет слой потоков экранов, всего их три: `LoginScenes`, `UsersScenes` и `GamesScenes`. В каждом содержится соответствующий координатор, экранные модули и фабрика этих модулей. Сверху содержится само приложение, которое просто собирает главный координатор из частей, лежащих на предыдущем слое. О каждом слое подробнее ниже.

### Storages
Для хранения данных используется `CoreData` и [CoreStore][CoreStore]. Последний облегчает работу, добавляя type safety, мониторинг объектов и листов, бэкграундные транзакции с меньшим количеством возможностей выстрелить себе в ногу и прочее. Так же важным плюсом является то, что можно создавать модели данных без графического редактора и программирования мышкой. В общем, получается Realm :)
На входе и выходе у стораджей простые структуры объектов, методы managed objects не экспоузятся наружу. По сути, из персистинга снаружи доступен только мониторинг изменений объектов. От этого тоже можно было абстрагироваться, но пожалел времени и не стал перфекционировать. Врочем, сделать это было бы не так сложно.
Стораджи используются через `Input` и `Output` протоколы, `Input` используют только сервисы, интеракторы экранов забирают данные через `Output`. Экранные модули получают данные реактивно, подписываясь на изменения стораджа.

### APIClient
Клиент содержит несколько протоколов клиентов для работы с разными сущностями, а так же структуры, необходимые для функционирования (`query`, `url factory`, etc). Реализации протоколов используют [Alamofire], но можно было бы обойтись и без него.

### Services
Сервисы для работы с сущностями, логаута и сравнения пользователей. Сказать особо нечего, получают данных, кладут в сторадж. SOA.

### UICommon
В этом модуле лежат ячейки таблиц и их модели, базовые экраны. Для лейаута используется [SnapKit], для загрузок картинок [Kingfisher]. Так же тут содержатся строки и картинки, обертки для них генерятся через [SwiftGen].

### Координаторы
Координаторы закрыты протоколом `Coordinatable`, которые имеет два associated type: `start option` и `result`. Эти типы лежат отдельно от координаторов уровнем ниже, фабрика координаторов инстанцирует type erased `AnyCoordinatable`. Таким образом координаторы никак не связаны и инстанцируют дочерние через фабрику, зная только о входных и выходных типах друг друга. Приятный бонус: при необходимости создать для одного координатора тестовое приложение создается фабрика, закрывающая остальные координаторы стабами (см. в коде `StubCoordinator` и `StubCoordinatorFactory`).
В проекте есть 3 абстрактных координатора, от коротрых наследуются все остальные: `WindowCoordinator`, `TabCoordinator` и `NavigationCoordinator`, думаю, что их назначение ясно.

### Экранный модуль
Экранные модули закрыты тем же протоколом, что и координаторы, отличие лишь в том, что сами они не инстанцируют дочерние модули, а передают управление в координатор.
Модуль преставляет собой VIPER-модуль без R. Так же из всех презентеров вынесен в отдельную сущность `ModelsBuilder`. По сути с имеющимся подходом к абстракции навигации и экранов не имеет значения архитектура конктертного модуля, т.к. она закрыта протоколом, применил VIPER, т.к. на работе использую его и так было быстрее.

### Графики
На самописные графики не хватило времени, в Telegram-контесте, увы, не участвовал. Использовал [Charts], как наиболее популярное и кастомизируемое решение.

### Дебаг
При запуске из xCode с переменной окружения `xDebugMode` (включена по умолчанию) на экране логина появляется кнопка `fake login` для авторизации под пользователем с хорошим аккаунтом по CS: GO.

### Тесты
На unit-тесты не хватило сил и времени, хотя изначально в планах было покрыть тестами все `Storages`. Но в качестве примеров тестов с созданием in-memory стораджа под каждый написал `AuthStorageTests`.

### GOD-mode
- ачивки пользователя по игре
- статус юзера
- экран сравнения себя с другим пользователем
- новости по игре (даже с картинками из html и bb codes)
- время, проведенное в игре за всю историю и за послендие 2 недели
- темная тема
- dynamic type
- UICommonTestApp
- дебаг-окружение
- модуляризация

### Pods

| Pod | Описание | URL |
| ------ | ------ | ------ |
| CoreStore | Хелпер CoreData | [https://github.com/JohnEstropia/CoreStore][CoreStore] |
| SnapKit | UI layaout | [https://github.com/SnapKit/SnapKit][SnapKit] |
| Kingfisher | Загрузка картинок | [https://github.com/onevcat/Kingfisher][Kingfisher] |
| Alamofire | Работа с сетью | https://github.com/Alamofire/Alamofire |
| Charts | Отрисовка графиков | https://github.com/danielgindi/Charts |
| SwiftGen | Кодогенерация для строк и картинок | https://github.com/SwiftGen/SwiftGen |

   [Alamofire]: <https://github.com/Alamofire/Alamofire>
   [CoreStore]: <https://github.com/JohnEstropia/CoreStore>
   [SnapKit]: <https://github.com/SnapKit/SnapKit>
   [Kingfisher]: <https://github.com/onevcat/Kingfisher>
   [Charts]: <https://github.com/danielgindi/Charts>
   [SwiftGen]: <https://github.com/SwiftGen/SwiftGen>